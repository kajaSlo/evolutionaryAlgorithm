<!DOCTYPE html>

<html>
<meta charset="UTF-8">

<head>
    <title>KajaSlomskaEvolutionaryAlgorithm</title>
    <script src="https://d3js.org/d3.v4.min.js"></script>
</head>

<body>
    <script>
        var amountOfParentShapeFunctionCalls = 0;

        function appendCircleUp(svg, x, y, len, jsonCircles) {

            var noDuplicates = true;

            for (var p = 0; p < jsonCircles.length; p++) {
                if ((jsonCircles[p]["x_axis"] == x + 5) && (jsonCircles[p]["y_axis"] == y + 5) &&
                    (jsonCircles[p]["radius"] == len / 2)) {
                    noDuplicates = false;
                }
            }

            if (noDuplicates == true) {
                var newCircle = {
                    "x_axis": x + 5,
                    "y_axis": y + 5,
                    "radius": len / 2,
                    "color": "yellow"
                };
                jsonCircles.push(newCircle);
            }
        }

        function appendRectangularUp(svg, x, y, len, jsonRectangulars, jsonCircles) {

            var noDuplicates = true;
            var isntThereACircle = true;

            for (var p = 0; p < jsonRectangulars.length; p++) {
                if ((jsonRectangulars[p]["x_axis"] == x) && (jsonRectangulars[p]["y_axis"] == y) &&
                    (jsonRectangulars[p]["width"] == len) && (jsonRectangulars[p]["height"] == len)) {
                    noDuplicates = false;
                }
            }

            for (var i = 0; i < jsonCircles.length; i++) {
                var circleX = jsonCircles[i]["x_axis"];
                var circleY = jsonCircles[i]["y_axis"];
                circleX = circleX - 5;
                circleY = circleY - 5;

                if ((x == circleX) && (y == circleY)) {
                    isntThereACircle = false;
                }
                circleX = 0;
                circleY = 0;
            }

            if (noDuplicates == true) {
                if (isntThereACircle == true) {
                    var newSquare = {
                        "x_axis": x,
                        "y_axis": y,
                        "width": len,
                        "height": len,
                        "color": "purple"
                    };
                    jsonRectangulars.push(newSquare);
                }
            }
        }

        function appendRectangularRight(svg, x, y, len, jsonRectangulars, jsonCircles) {

            var noDuplicates = true;
            var isntThereACircle = true;

            for (var p = 0; p < jsonRectangulars.length; p++) {
                if ((jsonRectangulars[p]["x_axis"] == x) && (jsonRectangulars[p]["y_axis"] == y) &&
                    (jsonRectangulars[p]["width"] == len) && (jsonRectangulars[p]["height"] == len)) {
                    noDuplicates = false;
                }
            }

            for (var i = 0; i < jsonCircles.length; i++) {
                var circleX = jsonCircles[i]["x_axis"];
                var circleY = jsonCircles[i]["y_axis"];
                circleX = circleX - 5;
                circleY = circleY - 5;

                if ((x == circleX) && (y == circleY)) {
                    isntThereACircle = false;
                }
                circleX = 0;
                circleY = 0;
            }
            if (noDuplicates == true) {
                if (isntThereACircle == true) {
                    var newSquareRight = {
                        "x_axis": x,
                        "y_axis": y,
                        "width": len,
                        "height": len,
                        "color": "purple"
                    };
                    jsonRectangulars.push(newSquareRight);
                }
            }
        }

        function appendCircleRight(svg, x, y, len, jsonCircles) {

            var noDuplicates = true;

            for (var p = 0; p < jsonCircles.length; p++) {
                if ((jsonCircles[p]["x_axis"] == x - 5 + len) && (jsonCircles[p]["y_axis"] == y + 5) &&
                    (jsonCircles[p]["radius"] == len / 2)) {
                    noDuplicates = false;
                }
            }

            if (noDuplicates == true) {
                var newCircle = {
                    "x_axis": x - 5 + len,
                    "y_axis": y + 5,
                    "radius": len / 2,
                    "color": "yellow"
                };
                jsonCircles.push(newCircle);
            }
        }

        function appendRectangularLeft(svg, x, y, len, jsonRectangulars, jsonCircles) {

            var noDuplicates = true;
            var isntThereACircle = true;

            for (var p = 0; p < jsonRectangulars.length; p++) {
                if ((jsonRectangulars[p]["x_axis"] == x + len - 10) && (jsonRectangulars[p]["y_axis"] == y) &&
                    (jsonRectangulars[p]["width"] == len) && (jsonRectangulars[p]["height"] == len)) {
                    noDuplicates = false;
                }
            }

            for (var i = 0; i < jsonCircles.length; i++) {
                var circleX = jsonCircles[i]["x_axis"];
                var circleY = jsonCircles[i]["y_axis"];
                circleX = circleX - 5;
                circleY = circleY - 5;

                if ((x + len - 10 == circleX) && (y == circleY)) {
                    isntThereACircle = false;
                }
                circleX = 0;
                circleY = 0;
            }
            if ((noDuplicates == true) && (isntThereACircle == true)) {
                var newSquareLeft = {
                    "x_axis": x + len - 10,
                    "y_axis": y,
                    "width": len,
                    "height": len,
                    "color": "purple"
                };
                jsonRectangulars.push(newSquareLeft);
            }
        }

        function appendCircleLeft(svg, x, y, len, jsonCircles) {

            var noDuplicates = true;

            for (var p = 0; p < jsonCircles.length; p++) {
                if ((jsonCircles[p]["x_axis"] == x - 5 + len) && (jsonCircles[p]["y_axis"] == y + 5) &&
                    (jsonCircles[p]["radius"] == len / 2)) {
                    noDuplicates = false;
                }
            }

            if (noDuplicates == true) {
                var newCircleLeft = {
                    "x_axis": x - 5 + len,
                    "y_axis": y + 5,
                    "radius": len / 2,
                    "color": "yellow"
                };
                jsonCircles.push(newCircleLeft);
            }
        }

        function appendRectangularDown(svg, x, y, len, jsonRectangulars, jsonCircles) {

            var noDuplicates = true;
            var isntThereACircle = true;

            for (var p = 0; p < jsonRectangulars.length; p++) {
                if ((jsonRectangulars[p]["x_axis"] == x + len - 10) && (jsonRectangulars[p]["y_axis"] == y) &&
                    (jsonRectangulars[p]["width"] == len) && (jsonRectangulars[p]["height"] == len)) {
                    noDuplicates = false;
                }
            }

            for (var i = 0; i < jsonCircles.length; i++) {
                var circleX = jsonCircles[i]["x_axis"];
                var circleY = jsonCircles[i]["y_axis"];
                circleX = circleX - 5;
                circleY = circleY - 5;

                if ((x + len - 10 == circleX) && (y == circleY)) {
                    isntThereACircle = false;
                }
                circleX = 0;
                circleY = 0;
            }

            if ((noDuplicates == true) && (isntThereACircle == true)) {
                var newSquareDown = {
                    "x_axis": x + len - 10,
                    "y_axis": y,
                    "width": len,
                    "height": len,
                    "color": "purple"
                };
                jsonRectangulars.push(newSquareDown);
            }
        }

        function appendCircleDown(svg, x, y, len, jsonCircles) {

            var noDuplicates = true;

            for (var p = 0; p < jsonCircles.length; p++) {
                if ((jsonCircles[p]["x_axis"] == x + len / 2) && (jsonCircles[p]["y_axis"] == y + len / 2) &&
                    (jsonCircles[p]["radius"] == len / 2)) {
                    noDuplicates = false;

                }
            }

            if (noDuplicates == true) {
                var newCircleDown = {
                    "x_axis": x + len / 2,
                    "y_axis": y + len / 2,
                    "radius": len / 2,
                    "color": "yellow"
                };
                jsonCircles.push(newCircleDown);
            }
        }

        function shape() {
            var shapeOrders = [];
            amountOfParentShapeFunctionCalls++;

            var svgShape = d3.select("body").append("svg")
                .attr("width", 500)
                .attr("height", 400);
            var jsonRectangulars = [];

            var square = {
                "x_axis": 400,
                "y_axis": 100,
                "width": 10,
                "height": 10,
                "color": "red"
            };
            jsonRectangulars.push(square);

            var jsonCircles = [];

            var rectangular = function(svg, x, y, len) {
                svgShape.selectAll("rect")
                    .data(jsonRectangulars)
                    .enter()
                    .append("rect")
                    .attr("x", function(svgXAxis) {
                        return svgXAxis.x_axis;
                    })
                    .attr("y", function(svgYAxis) {
                        return svgYAxis.y_axis;
                    })
                    .attr("width", function(svgWidth) {
                        return svgWidth.width;
                    })
                    .attr("height", function(svgHeigh) {
                        return svgHeigh.height;
                    })

                .attr("transform", "translate(-150, 0)")
                    .style("fill", function(svgColor) {
                        return svgColor.color;
                    });

                svgShape.append("text")
                    .style("fill", "black")
                    .attr("x", 100)
                    .attr("y", 20)
                    .attr("text-anchor", "up")
                    .text("Parent number " + amountOfParentShapeFunctionCalls);

                function appendAndDrawRectangularUp() {
                    shapeOrders.push("appendAndDrawRectangularUp");
                    appendRectangularUp(svg, x, y - len, len, jsonRectangulars, jsonCircles);
                    rectangular(svg, x, y - len, len);
                }

                function appendAndDrawCircleUp() {
                    shapeOrders.push("appendAndDrawCircleUp");
                    appendCircleUp(svg, x, y - len, len, jsonCircles);
                    circle(svg, x, y - len, len);
                }

                function appendAndDrawRectangularRight() {
                    shapeOrders.push("appendAndDrawRectangularRight");
                    appendRectangularRight(svg, x + len, y, len, jsonRectangulars, jsonCircles);
                    rectangular(svg, x + len, y, len);
                }

                function appendAndDrawCircleRight() {
                    shapeOrders.push("appendAndDrawCircleRight");
                    appendCircleRight(svg, x + len, y, len, jsonCircles);
                    circle(svg, x + len, y, len);
                }

                function appendAndDrawCircleLeft() {
                    shapeOrders.push("appendAndDrawCircleLeft");
                    appendCircleLeft(svg, x - len, y, len, jsonCircles);
                    circle(svg, x - len, y, len);
                }

                function appendAndDrawRectangularLeft() {
                    shapeOrders.push("appendAndDrawRectangularLeft");
                    appendRectangularLeft(svg, x - len, y, len, jsonRectangulars, jsonCircles);
                    rectangular(svg, x - len, y, len);
                }

                function appendAndDrawCircleDown() {
                    shapeOrders.push("appendAndDrawCircleDown");
                    appendCircleDown(svg, x, y + len, len, jsonCircles);
                    circle(svg, x, y + len, len);
                }

                function appendAndDrawRectangularDown() {
                    shapeOrders.push("appendAndDrawRectangularDown");
                    appendRectangularDown(svg, x, y + len, len, jsonRectangulars, jsonCircles);
                    rectangular(svg, x, y + len, len);
                }

                var shapeFunctionsArr = [appendAndDrawRectangularUp, appendAndDrawCircleUp, appendAndDrawRectangularRight, appendAndDrawCircleRight, appendAndDrawCircleLeft, appendAndDrawRectangularLeft, appendAndDrawCircleDown, appendAndDrawRectangularDown];

                rand = Math.floor(Math.random() * shapeFunctionsArr.length);
                randomShapeGrammar = shapeFunctionsArr[rand];
                randomShapeGrammar();
            }

            var circle = function(svg, x, y, len) {
                svgShape.selectAll("circle")
                    .data(jsonCircles)
                    .enter()
                    .append("circle")
                    .attr("cx", function(svgXAxis) {
                        return svgXAxis.x_axis;
                    })
                    .attr("cy", function(svgYAxis) {
                        return svgYAxis.y_axis;
                    })
                    .attr("r", function(svgRadius) {
                        return svgRadius.radius;
                    })
                    .attr("transform", "translate(-150, 0)")
                    .style("fill", function(svgColor) {
                        return svgColor.color;
                    });

                for (i = 0; i < jsonCircles.length; i++) {

                    if (jsonCircles[i]["x_axis"] > 500) {
                        return;
                    }

                    if (jsonCircles[i]["x_axis"] < 100) {
                        return;
                    }

                    if (jsonCircles[i]["y_axis"] < 50) {
                        return;
                    }
                    if (jsonCircles[i]["y_axis"] > 400) {
                        return;
                    }
                }

                function appendAndDrawRectangularUp() {
                    shapeOrders.push("appendAndDrawRectangularUp");
                    appendRectangularUp(svg, x, y - len, len, jsonRectangulars, jsonCircles);
                    rectangular(svg, x, y - len, len);
                }

                function appendAndDrawCircleUp() {
                    shapeOrders.push("appendAndDrawCircleUp");
                    appendCircleUp(svg, x, y - len, len, jsonCircles);
                    circle(svg, x, y - len, len);
                }

                function appendAndDrawRectangularRight() {
                    shapeOrders.push("appendAndDrawRectangularRight");
                    appendRectangularRight(svg, x + len, y, len, jsonRectangulars, jsonCircles);
                    rectangular(svg, x + len, y, len);
                }

                function appendAndDrawCircleRight() {
                    shapeOrders.push("appendAndDrawCircleRight");
                    appendCircleRight(svg, x + len, y, len, jsonCircles);
                    circle(svg, x + len, y, len);
                }

                function appendAndDrawCircleLeft() {
                    shapeOrders.push("appendAndDrawCircleLeft");
                    appendCircleLeft(svg, x - len, y, len, jsonCircles);
                    circle(svg, x - len, y, len);
                }

                function appendAndDrawRectangularLeft() {
                    shapeOrders.push("appendAndDrawRectangularLeft");
                    appendRectangularLeft(svg, x - len, y, len, jsonRectangulars, jsonCircles);
                    rectangular(svg, x - len, y, len);
                }

                function appendAndDrawCircleDown() {
                    shapeOrders.push("appendAndDrawCircleDown");
                    appendCircleDown(svg, x, y + len, len, jsonCircles);
                    circle(svg, x, y + len, len);
                }

                function appendAndDrawRectangularDown() {
                    shapeOrders.push("appendAndDrawRectangularDown");
                    appendRectangularDown(svg, x, y + len, len, jsonRectangulars, jsonCircles);
                    rectangular(svg, x, y + len, len);
                }

                var shapeFunctionsArr = [appendAndDrawRectangularUp, appendAndDrawCircleUp, appendAndDrawRectangularRight, appendAndDrawCircleRight, appendAndDrawCircleLeft, appendAndDrawRectangularLeft, appendAndDrawCircleDown, appendAndDrawRectangularDown],
                rand = Math.floor(Math.random() * shapeFunctionsArr.length);
                randomShapeGrammar = shapeFunctionsArr[rand];
                randomShapeGrammar();
            }

            rectangular(svgShape, 400, 100, 10);

            var amountOfRectangleMirrorsFound = 0;
            var shapeFunctionsArr = [];

            function rectangularGrade(distance) {

                var isLeftMirrorFound = false;
                var isRightMirrorFound = false;
                var leftMirror = 390 - (distance * 10);
                var rightMirror = 410 + (distance * 10);
                var yLocation = 100;
                var allPossibleLocationsOnYAxis = [];
                var mirrorXAndYAxisLocations = [];

                for (var i = 100; i < 500; i += 10) {
                    allPossibleLocationsOnYAxis.push(i);
                }

                for (var i = 100; i > 50; i -= 10) {
                    allPossibleLocationsOnYAxis.push(i);
                }

                for (l = 0; l < allPossibleLocationsOnYAxis.length; l++) {
                    yLocation = allPossibleLocationsOnYAxis[l];
                    for (i = 0; i < jsonRectangulars.length; i++) {

                        if ((jsonRectangulars[i]["x_axis"] == leftMirror) && (jsonRectangulars[i]["y_axis"] == yLocation)) {
                            isLeftMirrorFound = true;
                        }

                        if ((jsonRectangulars[i]["x_axis"] == rightMirror) && (jsonRectangulars[i]["y_axis"] == yLocation)) {
                            isRightMirrorFound = true;
                        }

                        if ((isLeftMirrorFound == true) && (isRightMirrorFound == true)) {
                            if ((mirrorXAndYAxisLocations[0] == leftMirror) && (mirrorXAndYAxisLocations[1] == rightMirror) && (mirrorXAndYAxisLocations[2] == yLocation)) {
                                continue;
                            } else {
                                mirrorXAndYAxisLocations = [];
                                mirrorXAndYAxisLocations.push(leftMirror);
                                mirrorXAndYAxisLocations.push(rightMirror);
                                mirrorXAndYAxisLocations.push(yLocation);
                                amountOfRectangleMirrorsFound += 1;
                            }
                        }
                    }
                    isLeftMirrorFound = false;
                    isRightMirrorFound = false;

                }
            }

            var rectangularDistance = 0;
            for (i = 0; i < jsonRectangulars.length; i++) {
                if ((jsonRectangulars[i]["x_axis"] < 500) && (jsonRectangulars[i]["x_axis"] > 100)) {
                    rectangularGrade(rectangularDistance);
                    rectangularDistance += 1;
                }
            }

            var amountOfCircleMirrorsFound = 0;

            function circleGrade(distance) {

                var isLeftMirrorFound = false;
                var isRightMirrorFound = false;
                var leftMirror = 395 - (distance * 10);
                var rightMirror = 415 + (distance * 10);
                var yLocation = 105;
                var allPossibleLocationsOnYAxis = [];
                var mirrorXAndYAxisLocations = [];

                for (var i = 105; i < 500; i += 10) {
                    allPossibleLocationsOnYAxis.push(i);
                }

                for (var i = 105; i > 50; i -= 10) {
                    allPossibleLocationsOnYAxis.push(i);
                }

                for (l = 0; l < allPossibleLocationsOnYAxis.length; l++) {
                    yLocation = allPossibleLocationsOnYAxis[l];
                    for (i = 0; i < jsonCircles.length; i++) {

                        if ((jsonCircles[i]["x_axis"] == leftMirror) && (jsonCircles[i]["y_axis"] == yLocation)) {
                            isLeftMirrorFound = true;
                        }

                        if ((jsonCircles[i]["x_axis"] == rightMirror) && (jsonCircles[i]["y_axis"] == yLocation)) {
                            isRightMirrorFound = true;
                        }

                        if ((isLeftMirrorFound == true) && (isRightMirrorFound == true)) {
                            if ((mirrorXAndYAxisLocations[0] == leftMirror) && (mirrorXAndYAxisLocations[1] == rightMirror) && (mirrorXAndYAxisLocations[2] == yLocation)) {
                                continue;
                            } else {
                                mirrorXAndYAxisLocations = [];
                                mirrorXAndYAxisLocations.push(leftMirror);
                                mirrorXAndYAxisLocations.push(rightMirror);
                                mirrorXAndYAxisLocations.push(yLocation);
                                amountOfCircleMirrorsFound += 1;

                            }
                        }
                    }
                    isLeftMirrorFound = false;
                    isRightMirrorFound = false;
                }
            }

            var circleDistance = 0;
            for (i = 0; i < jsonCircles.length; i++) {
                if ((jsonCircles[i]["x_axis"] < 500) && (jsonCircles[i]["x_axis"] > 100)) {
                    circleGrade(circleDistance);
                    circleDistance += 1;

                }
            }

            var totalShapeGrade = amountOfRectangleMirrorsFound + amountOfCircleMirrorsFound;

            return [
                jsonRectangulars,
                jsonCircles,
                totalShapeGrade,
                shapeOrders,
                amountOfParentShapeFunctionCalls
            ];
        }

        var amountOfChildShapeFunctionCalls = 0;

        function createAChildFromParents(firstParent, secondParent) {

            var shapeOrders = [];
            var jsonRectangulars = [];

            var square = {
                "x_axis": 400,
                "y_axis": 100,
                "width": 10,
                "height": 10,
                "color": "red"
            };
            jsonRectangulars.push(square);

            var jsonCircles = [];

            amountOfChildShapeFunctionCalls++;
            var svgShape = d3.select("body").append("svg")
                .attr("width", 500)
                .attr("height", 400);

                function drawSelectedShapeFuntion(drawnShapeFunction, svg, x, y, len, jsonRectangulars, jsonCircles, shapeFunctionsArr) {               

                switch (drawnShapeFunction) {
                        case "appendAndDrawRectangularUp":
                            shapeOrders.push("appendAndDrawRectangularUp");
                            appendRectangularUp(svg, x, y - len, len, jsonRectangulars, jsonCircles);
                            rectangular(svg, x, y - len, len, shapeFunctionsArr);
                            break;
                        case "appendAndDrawCircleUp":
                            shapeOrders.push("appendAndDrawCircleUp");
                            appendCircleUp(svg, x, y - len, len, jsonCircles);
                            circle(svg, x, y - len, len, shapeFunctionsArr);
                            break;
                        case "appendAndDrawRectangularRight":
                            shapeOrders.push("appendAndDrawRectangularRight");
                            appendRectangularRight(svg, x + len, y, len, jsonRectangulars, jsonCircles);
                            rectangular(svg, x + len, y, len, shapeFunctionsArr);
                            break;
                        case "appendAndDrawCircleRight":
                            shapeOrders.push("appendAndDrawCircleRight");
                            appendCircleRight(svg, x + len, y, len, jsonCircles);
                            circle(svg, x + len, y, len, shapeFunctionsArr);
                            break;
                        case "appendAndDrawCircleLeft":
                            shapeOrders.push("appendAndDrawCircleLeft");
                            appendCircleLeft(svg, x - len, y, len, jsonCircles);
                            circle(svg, x - len, y, len, shapeFunctionsArr);
                            break;
                        case "appendAndDrawRectangularLeft":
                            shapeOrders.push("appendAndDrawRectangularLeft");
                            appendRectangularLeft(svg, x - len, y, len, jsonRectangulars, jsonCircles);
                            rectangular(svg, x - len, y, len, shapeFunctionsArr);
                            break;
                        case "appendAndDrawCircleDown":
                            shapeOrders.push("appendAndDrawCircleDown");
                            appendCircleDown(svg, x, y + len, len, jsonCircles);
                            circle(svg, x, y + len, len, shapeFunctionsArr);
                            break;
                        case "appendAndDrawRectangularDown":
                            shapeOrders.push("appendAndDrawRectangularDown");
                            appendRectangularDown(svg, x, y + len, len, jsonRectangulars, jsonCircles);
                            rectangular(svg, x, y + len, len, shapeFunctionsArr);
                    }
                }

            var rectangular = function(svg, x, y, len, shapeFunctionsArr) {
                svgShape.selectAll("rect")
                    .data(jsonRectangulars)
                    .enter()
                    .append("rect")
                    .attr("x", function(svgXAxis) {
                        return svgXAxis.x_axis;
                    })
                    .attr("y", function(svgYAxis) {
                        return svgYAxis.y_axis;
                    })
                    .attr("width", function(svgWidth) {
                        return svgWidth.width;
                    })
                    .attr("height", function(svgHeigh) {
                        return svgHeigh.height;
                    })

                .attr("transform", "translate(-150, 0)")
                    .style("fill", function(svgColor) {
                        return svgColor.color;
                    });

                svgShape.append("text")
                    .style("fill", "black")
                    .attr("x", 100)
                    .attr("y", 20)
                    .attr("text-anchor", "up")
                    .text("Child number " + amountOfChildShapeFunctionCalls + " from parents " + firstParent[4] + " and " + secondParent[4]);

                var drawnShapeFunction = shapeFunctionsArr[0];
                if (shapeFunctionsArr.length != 0) {
                    shapeFunctionsArr.shift();
                    drawSelectedShapeFuntion(drawnShapeFunction, svg, x, y, len, jsonRectangulars, jsonCircles, shapeFunctionsArr);
                }
            }

            var circle = function(svg, x, y, len, shapeFunctionsArr) {
                svgShape.selectAll("circle")
                    .data(jsonCircles)
                    .enter()
                    .append("circle")
                    .attr("cx", function(svgXAxis) {
                        return svgXAxis.x_axis;
                    })
                    .attr("cy", function(svgYAxis) {
                        return svgYAxis.y_axis;
                    })
                    .attr("r", function(svgRadius) {
                        return svgRadius.radius;
                    })
                    .attr("transform", "translate(-150, 0)")
                    .style("fill", function(svgColor) {
                        return svgColor.color;
                    });

                for (i = 0; i < jsonCircles.length; i++) {

                    if (jsonCircles[i]["x_axis"] > 500) {
                        return;
                    }

                    if (jsonCircles[i]["x_axis"] < 100) {
                        return;
                    }

                    if (jsonCircles[i]["y_axis"] < 50) {
                        return;
                    }
                    if (jsonCircles[i]["y_axis"] > 400) {
                        return;
                    }
                }

                var drawnShapeFunction = shapeFunctionsArr[0];
                if (shapeFunctionsArr.length != 0) {
                    shapeFunctionsArr.shift();
                    drawSelectedShapeFuntion(drawnShapeFunction, svg, x, y, len, jsonRectangulars, jsonCircles, shapeFunctionsArr);
                }
            }

            var halfOfFirstParentProductionsLength = parseInt(firstParent[3].length / 2);
            var halfOfSecondParentProductionsLength = parseInt(secondParent[3].length / 2);

            var divergence = [-3, -2, -1, 0, 1, 2, 3];

            var randDevergence = Math.floor(Math.random() * divergence.length);

            halfOfFirstParentProductionsLength = halfOfFirstParentProductionsLength + randDevergence;
            halfOfSecondParentProductionsLength = halfOfSecondParentProductionsLength - randDevergence;

            var firstChild = [];
            for (var i = 0; i < halfOfFirstParentProductionsLength; i++) {
                firstChild.push(firstParent[3][i])
            }

            for (var i = halfOfSecondParentProductionsLength; i < secondParent[3].length; i++) {
                firstChild.push(secondParent[3][i])
            }
            rectangular(svgShape, 400, 100, 10, firstChild);

            var amountOfRectangleMirrorsFound = 0;
            var shapeFunctionsArr = [];

            function rectangularGrade(distance) {

                var isLeftMirrorFound = false;
                var isRightMirrorFound = false;
                var leftMirror = 390 - (distance * 10);
                var rightMirror = 410 + (distance * 10);
                var yLocation = 100;
                var allPossibleLocationsOnYAxis = [];
                var mirrorXAndYAxisLocations = [];

                for (var i = 100; i < 500; i += 10) {
                    allPossibleLocationsOnYAxis.push(i);
                }

                for (var i = 100; i > 50; i -= 10) {
                    allPossibleLocationsOnYAxis.push(i);
                }

                for (l = 0; l < allPossibleLocationsOnYAxis.length; l++) {
                    yLocation = allPossibleLocationsOnYAxis[l];
                    for (i = 0; i < jsonRectangulars.length; i++) {

                        if ((jsonRectangulars[i]["x_axis"] == leftMirror) && (jsonRectangulars[i]["y_axis"] == yLocation)) {
                            isLeftMirrorFound = true;
                        }

                        if ((jsonRectangulars[i]["x_axis"] == rightMirror) && (jsonRectangulars[i]["y_axis"] == yLocation)) {
                            isRightMirrorFound = true;
                        }

                        if ((isLeftMirrorFound == true) && (isRightMirrorFound == true)) {
                            if ((mirrorXAndYAxisLocations[0] == leftMirror) && (mirrorXAndYAxisLocations[1] == rightMirror) && (mirrorXAndYAxisLocations[2] == yLocation)) {
                                continue;
                            } else {
                                mirrorXAndYAxisLocations = [];
                                mirrorXAndYAxisLocations.push(leftMirror);
                                mirrorXAndYAxisLocations.push(rightMirror);
                                mirrorXAndYAxisLocations.push(yLocation);
                                amountOfRectangleMirrorsFound += 1;
                            }
                        }
                    }
                    isLeftMirrorFound = false;
                    isRightMirrorFound = false;
                }
            }

            var rectangularDistance = 0;
            for (i = 0; i < jsonRectangulars.length; i++) {
                if ((jsonRectangulars[i]["x_axis"] < 500) && (jsonRectangulars[i]["x_axis"] > 100)) {
                    rectangularGrade(rectangularDistance);
                    rectangularDistance += 1;
                }
            }

            var amountOfCircleMirrorsFound = 0;

            function circleGrade(distance) {

                var isLeftMirrorFound = false;
                var isRightMirrorFound = false;
                var leftMirror = 395 - (distance * 10);
                var rightMirror = 415 + (distance * 10);
                var yLocation = 105;
                var allPossibleLocationsOnYAxis = [];
                var mirrorXAndYAxisLocations = [];

                for (var i = 105; i < 500; i += 10) {
                    allPossibleLocationsOnYAxis.push(i);
                }

                for (var i = 105; i > 50; i -= 10) {
                    allPossibleLocationsOnYAxis.push(i);
                }

                for (l = 0; l < allPossibleLocationsOnYAxis.length; l++) {
                    yLocation = allPossibleLocationsOnYAxis[l];
                    for (i = 0; i < jsonCircles.length; i++) {

                        if ((jsonCircles[i]["x_axis"] == leftMirror) && (jsonCircles[i]["y_axis"] == yLocation)) {
                            isLeftMirrorFound = true;
                        }

                        if ((jsonCircles[i]["x_axis"] == rightMirror) && (jsonCircles[i]["y_axis"] == yLocation)) {
                            isRightMirrorFound = true;
                        }

                        if ((isLeftMirrorFound == true) && (isRightMirrorFound == true)) {
                            if ((mirrorXAndYAxisLocations[0] == leftMirror) && (mirrorXAndYAxisLocations[1] == rightMirror) && (mirrorXAndYAxisLocations[2] == yLocation)) {
                                continue;
                            } else {
                                mirrorXAndYAxisLocations = [];
                                mirrorXAndYAxisLocations.push(leftMirror);
                                mirrorXAndYAxisLocations.push(rightMirror);
                                mirrorXAndYAxisLocations.push(yLocation);
                                amountOfCircleMirrorsFound += 1;

                            }
                        }
                    }
                    isLeftMirrorFound = false;
                    isRightMirrorFound = false;
                }
            }

            var circleDistance = 0;
            for (i = 0; i < jsonCircles.length; i++) {
                if ((jsonCircles[i]["x_axis"] < 500) && (jsonCircles[i]["x_axis"] > 100)) {
                    circleGrade(circleDistance);
                    circleDistance += 1;
                }
            }

            var totalShapeGrade = amountOfRectangleMirrorsFound + amountOfCircleMirrorsFound;

            return [
                jsonRectangulars,
                jsonCircles,
                totalShapeGrade,
                shapeOrders,
                amountOfChildShapeFunctionCalls
            ];
        }

        var amountOfParents = 10;

        function randomParentsWithTheBestGrade(halfOfTheParentsWithTheBestShapeGrade) {

        var chosenRandomParentsWithTheBestGrade = [];
        randFirstParent = Math.floor(Math.random() * halfOfTheParentsWithTheBestShapeGrade.length);

        firstParentToInheritFrom = halfOfTheParentsWithTheBestShapeGrade[randFirstParent];
        halfOfTheParentsWithTheBestShapeGrade.splice(randFirstParent, 1);
        randSecondParent = Math.floor(Math.random() * halfOfTheParentsWithTheBestShapeGrade.length);
        secondParentToInheritFrom = halfOfTheParentsWithTheBestShapeGrade[randSecondParent];

        halfOfTheParentsWithTheBestShapeGrade.push(firstParentToInheritFrom);

        var thisPairAlreadyExists = "false";
        for (var i = 0; i < chosenRandomParentsWithTheBestGrade.length; i += 2) {

            if ((firstParentToInheritFrom == chosenRandomParentsWithTheBestGrade[i]) && (secondParentToInheritFrom == chosenRandomParentsWithTheBestGrade[i + 1])) {
                thisPairAlreadyExists = "true";
            }
        }

        if (thisPairAlreadyExists == "true") {
            delete firstParentToInheritFrom;
            delete secondParentToInheritFrom;
            randomParentsWithTheBestGrade(halfOfTheParentsWithTheBestShapeGrade);
        } else {
            chosenRandomParentsWithTheBestGrade.push(firstParentToInheritFrom);
            chosenRandomParentsWithTheBestGrade.push(secondParentToInheritFrom);
            delete firstParentToInheritFrom;
            delete secondParentToInheritFrom;
        }
        return chosenRandomParentsWithTheBestGrade;
        }

        function createParents(amountOfParents) {

            var parents = [];

            for (var i = 0; i < amountOfParents; i++) {
                var parent = shape();
                parents.push(parent);
            }

            parents.sort(function(a, b) {
                return a[2] - b[2]
            })

            function parentsGradesArray(Parents) {
                var quote = "";
                for (var i = 0; i < parents.length; i++) {
                    quote += "grade: " + parents[i][2] + " ";
                    quote += " parent no " + parents[i][4] + ", ";

                }
                return quote;
            }

            var svgContainer = d3.select("body").append("svg")
                .attr("width", 2000)
                .attr("height", 150);

            svgContainer.append("text")
                .style("fill", "black")
                .attr("x", 100)
                .attr("y", 100)
                .attr("text-anchor", "up")
                .text("Parents and their grades " + parentsGradesArray(parents));

            var halfOfParentsShapes = parseInt(parents.length / 2);

            var halfOfTheParentsWithTheBestShapeGrade = [];

            for (var i = halfOfParentsShapes; i < parents.length; i++) {
                halfOfTheParentsWithTheBestShapeGrade.push(parents[i]);
            }

            var parentsWithTheBestShapeGrade = [];

            for (var i = 0; i < amountOfParents; i++) {
                var selectedParentsWithTheBestShapeGrade = randomParentsWithTheBestGrade(halfOfTheParentsWithTheBestShapeGrade);
                parentsWithTheBestShapeGrade.push(selectedParentsWithTheBestShapeGrade[0]);
                parentsWithTheBestShapeGrade.push(selectedParentsWithTheBestShapeGrade[1]);
            }
            return parentsWithTheBestShapeGrade;
        }

        function anotherGen(parents) {

            function createAnotherChildren(parents) {
                parents.sort(function(a, b) {
                    return a[2] - b[2]
                })

                function parentsGradesArray(parents) {
                    var quote = "";
                    for (var i = 0; i < parents.length; i++) {

                        quote += "grade: " + parents[i][2] + " ";
                        quote += " parent no " + parents[i][4] + ", ";

                    }
                    return quote;

                    function cut(str, cutStart, cutEnd) {
                        return str.substr(0, cutStart) + str.substr(cutEnd + 1);
                    }
                    quote = cut(quote, 0, cut.length);
                }

                var svgLine= d3.select("body").append("svg")
                    .attr("width", 2000)
                    .attr("height", 50);

                var line = svgLine.append("line")
                    .attr("x1", 5)
                    .attr("y1", 5)
                    .attr("x2", 2000)
                    .attr("y2", 5)
                    .attr("stroke-width", 2)
                    .attr("stroke", "black");

                var svgText = d3.select("body").append("svg")
                    .attr("width", 2000)
                    .attr("height", 150);

                    svgText.append("text")
                    .style("fill", "black")
                    .attr("x", 0)
                    .attr("y", 100)
                    .attr("text-anchor", "up")
                    .text("Parents and their grades " + parentsGradesArray(parents));

                var halfOfParentsShapes = parseInt(parents.length / 2);

                var halfOfTheParentsWithTheBestShapeGrade = [];

                for (var i = halfOfParentsShapes; i < parents.length; i++) {
                    halfOfTheParentsWithTheBestShapeGrade.push(parents[i]);
                }

                var parentsWithTheBestShapeGrade = [];

                for (var i = 0; i < amountOfParents; i++) {
                    var selectedParentsWithTheBestShapeGrade = randomParentsWithTheBestGrade(halfOfTheParentsWithTheBestShapeGrade);
                    parentsWithTheBestShapeGrade.push(selectedParentsWithTheBestShapeGrade[0]);
                    parentsWithTheBestShapeGrade.push(selectedParentsWithTheBestShapeGrade[1]);
                }

                return parentsWithTheBestShapeGrade;
            }

            var nextGeneration = createAnotherChildren(parents);

            var childrenFromWhichTheirChildrenWillBeCreated = [];
            var shapeFunctionsArr = ["appendAndDrawRectangularUp", "appendAndDrawCircleUp", "appendAndDrawRectangularRight", "appendAndDrawCircleRight", "appendAndDrawCircleLeft", "appendAndDrawRectangularLeft", "appendAndDrawCircleDown", "appendAndDrawRectangularDown"];
            randChildPosition = Math.floor(Math.random() * shapeFunctionsArr.length);

            //mutation
            var childrenLength = nextGeneration.length;
            var percent = 3 / 100;
            var howManyChildrenHaveToMutate = parseInt(percent * childrenLength);

            for (var i = 0; i < howManyChildrenHaveToMutate; i++) {

                randChildWhichWillMutate = Math.floor(Math.random() * nextGeneration.length); 

                randProductionFromAChildWhichWillMutate = Math.floor(Math.random() * nextGeneration[randChildWhichWillMutate][3].length); 

                for (var i = 0; i < shapeFunctionsArr.length; i++) {

                    if (shapeFunctionsArr[i] == nextGeneration[randChildWhichWillMutate][3][randProductionFromAChildWhichWillMutate]) {
                        var item = shapeFunctionsArr[i];
                        delete shapeFunctionsArr[i];
                        randProductionWithWhichAChildWillMutate = Math.floor(Math.random() * shapeFunctionsArr.length); 
                        nextGeneration[randChildWhichWillMutate][3][randProductionFromAChildWhichWillMutate] = nextGeneration[randChildWhichWillMutate][3][randProductionWithWhichAChildWillMutate];
                        shapeFunctionsArr.push(item);
                    }
                }

                randProductionWithWhichAChildWillMutate = Math.floor(Math.random() * shapeFunctionsArr.length);
                i--;

            }

            for (var i = 0; i < nextGeneration.length; i += 2) {
                var child = createAChildFromParents(nextGeneration[i], nextGeneration[i + 1]);
                childrenFromWhichTheirChildrenWillBeCreated.push(child);
            }

            return childrenFromWhichTheirChildrenWillBeCreated;
        }

        var amountOfGenerations = 6; //here amount of generations can be changed and a program will draw chosen amount of generations

        function createParentsAndFirstChildrenGeneration(amountOfParents) {
            var allParents = createParents(amountOfParents);

            var svgLine = d3.select("body").append("svg")
                .attr("width", 2000)
                .attr("height", 100);

            var line = svgLine.append("line")
                .attr("x1", 5)
                .attr("y1", 5)
                .attr("x2", 2000)
                .attr("y2", 5)
                .attr("stroke-width", 2)
                .attr("stroke", "black");

            var firstChildrenGeneration = [];
            for (var i = 0; i < allParents.length; i += 2) {

                var child = createAChildFromParents(allParents[i], allParents[i + 1]);
                firstChildrenGeneration.push(child);
            }

            return firstChildrenGeneration;
        }

        if (amountOfGenerations == 1) {
            var allParents = createParents(amountOfParents);
        } else if (amountOfGenerations == 2) {
           var childrenFromWhichTheirChildrenWillBeCreated = createParentsAndFirstChildrenGeneration(amountOfParents);

        } else if (amountOfGenerations == 3) {
            var childrenFromWhichTheirChildrenWillBeCreated = createParentsAndFirstChildrenGeneration(amountOfParents);
            var nextGeneration = anotherGen(childrenFromWhichTheirChildrenWillBeCreated);

        } else {
            var childrenFromWhichTheirChildrenWillBeCreated = createParentsAndFirstChildrenGeneration(amountOfParents);
            var amountOfChildShapeFunctionCalls = 0;

            var nextGeneration = anotherGen(childrenFromWhichTheirChildrenWillBeCreated);

            amountOfGenerations = amountOfGenerations - 3;

            while (amountOfGenerations > 0) {
                if (amountOfGenerations >= 2) {
                    var amountOfChildShapeFunctionCalls = 0;
                    var another = anotherGen(nextGeneration);
                    var nextGeneration = 0;

                    var amountOfChildShapeFunctionCalls = 0;
                    var nextGeneration = anotherGen(another);
                    var another = 0;
                    var amountOfChildShapeFunctionCalls = 0;

                    amountOfGenerations = amountOfGenerations - 2;
                } else {
                    var amountOfChildShapeFunctionCalls = 0;
                    var lastGeneration = anotherGen(nextGeneration);
                    amountOfGenerations = amountOfGenerations - 1;
                }
            }
        }
    </script>
</body>
</html>
